## Часть II
## Абстракция данных

В предыдущей части мы рассмотрели, как процедуры описывают вычислительные процессы. В этой части мы обратим наше внимание на данные, которыми манипулируют эти процессы и как они могут быть структурированы. Существует много качественно разных способов структурирования данных. Например, список остановок для автобусного маршрута имеет мало общего с чьим-то семейным деревом. В этой части мы сосредоточимся на нескольких характерных структурах данных и наборе операций, подходящих для каждого из них.

In the previous part, we looked at how procedures describe computational processes. In this part, we will turn our attention to the data that is manipulated by those processes and how it can be structured. There are many qualitatively dissimilar ways of structuring data. For example, the list of stops for a bus route bears little resemblance to someone’s family tree. In this part, we’ll focus on a few representative data structures and the collection of operations that is appropriate to each one.

В главе 6 мы рассмотрим основы использования и представления составных данных в относительно простом контексте типов данных с фиксированным числом компонентов. Мы сосредоточимся на наборе операций, которые образуют интерфейс между использованием типа данных и его представлением. В главе 7 мы покажем, как двухкомпонентные структуры данных могут фактически использоваться для представления списков любой длины, рассматривая каждый непустой список как имеющий первый элемент и список остальных элементов. Мы продолжим этот рекурсивный подход к структурированию данных для иерархических древовидных структур в главе 8. Далее мы рассмотрим, как разнообразная коллекция различных представлений данных может представлять единый, универсальный набор операций интерфейса. Наконец, мы рассмотрим программы как сами по себе иерархически скомпонованные данные (выражения, сделанные из подвыражений), и посмотрим, как обеспечить равномерную операцию «оценки» для разнообразия разных типов выражений. Поступая таким образом, мы покажем, что реализация языка программирования - это действительно конкретное приложение методов, представленных в этой части книги.

In Chapter 6, we’ll work through the fundamentals of using and representing compound data in the relatively simple context of data types with a fixed number of components. Our focus is on the collection of operations that forms the interface between the uses of the data type and its representation. In Chapter 7, we’ll show how two-component data structures can actually be used to represent lists of any length, by treating each nonempty list as having a first element and a list of the remaining elements. We’ll extend this recursive approach to structuring data to hierarchical, tree-like structures in Chapter 8. Next we’ll examine how a diverse collection of different data representations can present a single, uniform collection of interface operations. Finally, we’ll look at programs as themselves being hierarchically composed data (expressions made of subexpressions) and see how to provide a uniform “evaluate” operation across the diversity of different expression types. By doing so, we’ll show that implementing a programming language is really a specific application of the techniques introduced in this part of the book.

### Глава 6
### Составные данные и абстракция данных
#### 6.1 Введение

До сих пор каждое значение, переданное одной из наших процедур в качестве аргумента или возвращаемое в результате, было единственной вещью: числом, изображением, значением истины или процедурой. Если мы хотим передать процедуре два числа, нам нужны два отдельных аргумента, потому что каждое значение аргумента может быть только одной вещью. Такие данные называются атомарными данными. С другой стороны, вы можете легко представить себе программы, которые используют более сложные данные. Например, программа, которая играет в покер, использует руки карт. Там может быть процедура сравнения рук, которая принимает два аргумента, а именно две руки для сравнения, и отчеты, которые лучше. Каждый аргумент этой процедуры - это одна вещь, а именно рука. Тем не менее, мы также можем выбрать отдельную карту из руки. Таким образом, в то время как рука - это единая вещь, она также является коллекцией компонентных карт. Как насчет самих карт? Каждая карта - это однозначно одна вещь, но мы также можем рассматривать ее как комбинацию костюма и ранга. Такие данные, которые мы можем интерпретировать как единый объект, а также как набор частей, называются составными данными.

Up until now, each value passed to one of our procedures as an argument or returned as a result was a single thing: a number, an image, a truth value, or a procedure. If we wanted to pass a procedure two numbers, we needed two separate arguments, because each argument value could only be a single thing. This kind of data is called atomic data. On the other hand, you can easily think of programs that use more complex data. For example, a program that plays poker would use hands of cards. There might be a compare-hands procedure that takes two arguments, namely, the two hands to compare, and reports which is better. Each argument to this procedure is a single thing, namely, a hand. Yet we can also select an individual card from a hand. So, at the same time as the hand is a single thing, it is also a collection of component cards. How about the cards themselves? Each card is clearly a single thing, yet we can also treat it as a combination of a suit and a rank. Data such as this, which we can interpret as both a single entity and also as a collection of parts, is called compound data.

Чтобы увидеть, как мы можем заставить компьютер перемещаться по этим странным водам между сингулярным и множественным числом, рассмотрим следующий сценарий. Предположим, вы запустили компанию по заказу по почте и хотите начать продавать заказные «носки» для хвостов кошек - отлично для тех холодных ночей. (Полагаю, вы все поймете на рынке). Проблема заключается в том, что в вашем бланке заказа есть место только для одного номера модели, но заказчику нужно указать длину (до ближайшего сантиметра), а также независимо от того, Им нужна версия deluxe (мохер). Другими словами, они должны отправить вам комбинацию числа (длины) и истинного значения (независимо от того, будет или нет), но можете отправить только одну вещь - номер модели. Чем ты занимаешься? Вы нанимаете консалтинговую фирму.

In order to see how we can get a computer to navigate these strange waters between singular and plural, consider the following scenario. Suppose you run a mail-order company and want to start selling custom-knit “socks” for cats’ tails—great for those cold nights. (You figure you’ll have the market all to yourself.) The problem is, your order form only has space for a single model number, but the customer needs to specify both the length (to the nearest centimeter) and also whether or not they want the deluxe (mohair) version. In other words, they need to send you a combination of a number (the length) and a truth value (whether or not deluxe) but can only send in one thing—the model number. What do you do? You hire a consulting firm.

Консалтинговая фирма разрабатывает три калькулятора типа гизмо с клавиатурами и дисплеями. Один из них, конструктор, должен быть отправлен вашим клиентам вместе со своими каталогами. Он строит номер модели по длине и выбору deluxeness. Другие две вещицы, селектора, предназначены для использования в вашей компании. Селектор deluxeness отображает «да» или «нет» на своем дисплее при вводе номера модели. При вводе номера модели селектор длины показывает длину в сантиметрах.

The consulting firm designs three calculator-like gizmos with keypads and displays. One of them, the constructor, is to be mailed out to your customers along with their catalogs. It constructs the model number from the length and the deluxeness choice. The other two gizmos, the selectors, are for use at your company. The deluxeness selector displays “yes” or “no” on its display when you enter a model number. The length selector displays the length in centimeters when you enter a model number.

Вы и ваши клиенты можете использовать эти устройства без необходимости знать что-либо о том, как они работают. В частности, вам не нужно знать, как две части информации закодированы в номер модели. Напротив, консультанты, разработавшие гизмосы (и которые, вероятно, будут единственными, кто разбогатеет по всей этой необдуманной схеме), должны решить эту кодировку. Им нужно выбрать конкретное представление двух частей информации, и это же представление должно быть воплощено как в конструкторе, так и в селекторах.

You and your customers can use these devices without needing to know anything about how they work. In particular, you don’t need to know how the two pieces of information are encoded into the model number. In contrast, the consultants who designed the gizmos (and who are likely to be the only ones who get rich on this whole harebrained scheme) need to decide on this encoding. They need to choose a particular representation of the two pieces of information, and this same representation needs to be embodied in both the constructor and the selectors.

Эта идея, что представление данных может быть исключительно заботой конструктора и селекторов, а не конечных создателей и пользователей данных, называется абстракцией данных. В несколько более общих терминах абстракция данных относится к разделению способа использования нового типа данных по способу представления. Это означает, что когда мы добавляем новый тип данных, мы сначала решаем, какие операции (процедуры) необходимы для создания и манипулирования значениями данных. Затем мы выясним хороший способ представления значений данных с использованием типов, которые уже являются частью нашей системы Scheme. Наконец, мы находим алгоритмы, необходимые для реализации основных операций. Всякий раз, когда мы используем новый тип данных в другой программе, мы создаем и манипулируем значениями данных только с помощью основных операций, а не посредством доступа к базовому представлению данных.

This idea, that the representation of data can be exclusively the concern of a constructor and selectors, rather than of the ultimate creators and users of the data, is known as data abstraction. In slightly more general terms, data abstraction refers to separating the way a new type of data is used from the way it is represented. This means that when we add a new data type, we first decide what operations (procedures) are necessary to create and manipulate the data values. Then we figure out a good way of representing the data values using the types that are already part of our Scheme system. Finally, we find algorithms necessary for implementing the essential operations. Whenever we use the new data type in another program, we create and manipulate the data values only by using the essential operations, and not by accessing the underlying representation of the data.

Самодисциплина абстракции данных приносит три награды. Прежде всего, указав основные операции, которые манипулируют новым типом данных, программисту не нужно беспокоиться о том, как фактически отображаются значения данных. Это означает, что она может работать с абстрактной моделью данных, которые она имеет в своей голове, вместо того, чтобы постоянно переключаться с модели на базовое представление и обратно. (Говорят, что программист, работающий в этом независимом от представления виде, использует абстрактный тип данных или ADT.) Во-вторых, если мы отделим способ использования данных от того, как они реализованы, реализация может быть разработана независимо от программ Используя данные. Из-за этого мы часто можем разбить большой проект программирования на части, которые одновременно могут работать разные команды программистов. Наконец, поскольку прикладные программы обращаются к данным только через основные операции, мы можем легко изменить способ представления данных, просто изменив эти процедуры. В частности, если мы хотим переместить крупную программу (например, систему Scheme) с одного типа компьютера на другой (этот процесс называется портированием), большая часть работы ограничена модификацией реализаций ADT.

The self-discipline of data abstraction brings three rewards. First of all, by specifying the basic operations that manipulate the new data type, the programmer needn’t worry about how the data values are actually represented. This means that she can work with the abstract model of the data that she has in her head rather than constantly switching from the model to the underlying representation and back. (A programmer working in this representation-independent way is said to be using an abstract data type, or ADT .) Secondly, if we separate the way the data is used from how it is implemented, the implementation can be developed independently from the programs using the data. Because of this, we can often break down a large programming project into pieces that different teams of programmers can work on simultaneously. Finally, because the application programs access the data only through the basic operations, we can easily change the way the data is represented by simply changing these procedures. In particular, if we want to move a large software program (such as the Scheme system) from one type of computer to another (this process is called porting), a lot of the work is restricted to modifying the ADT implementations.

В оставшейся части этой главы мы проиллюстрируем технику абстракции данных, написав программу, которая играет в игру Nim. Это наш первый пример интерактивной программы, тем самым вводя читателя в некоторые простые процедуры ввода и вывода в Scheme. В большей части этой главы наши составные данные будут содержать только два компонента; Однако мы покажем, как создавать типы данных с тремя компонентами в разделе 6.4. Этот метод может быть распространен на любое (фиксированное) количество компонентов. В разделе нашего приложения рассматривается использование более высокого порядка программирования вместе с абстракцией данных для добавления стратегий в игру Nim.

In the remainder of this chapter, we illustrate the technique of data abstraction by writing a program that plays the game of Nim. This is our first example of an interactive program, thereby introducing the reader to some simple input and output procedures in Scheme. For most of this chapter, our compound data will have only two components; however, we show how to create data types with three components in Section 6.4. This technique can be extended to any (fixed) number of components. Our application section considers how to use higher-order programming together with data abstraction to add strategies to the game of Nim.

В последующих главах мы рассматриваем более сложные структуры данных, такие как списки и иерархически структурированные данные, которые не ограничивают количество компонентов в данных. Мы также рассматриваем сложные «общие» операторы, которые могут использоваться для нескольких типов данных. Наконец, мы применяем эти идеи к особому виду сложных данных, программам и особенно интересной операции - запуску этих программ.

In later chapters, we consider more complex data structures, such as lists and hierarchically structured data, that do not restrict the number of components in the data. We also consider complex “generic” operators that can be used on multiple data types. Finally, we apply these ideas to one very special kind of compound data, programs, and a particularly interesting operation, the running of those programs.

### 6.1 Игра Nim

В этом разделе мы начнем писать процедуры для воспроизведения вариаций в игре Nim. Первое появление «официальных» правил для Нима содержится в статье Чарльза Бутона в 1901 году, в которой он проанализировал игру и представил выигрышную стратегию. Однако, как и во многих неофициальных народных играх, существует множество различных способов игры с Нимом. Все варианты начинаются с объектов, которые каким-то образом устроены. Два игрока поочередно удаляют объекты по определенным правилам, а игрок, который берет последний объект, является победителем (или проигравшим, в некоторых вариантах). Мы представляем три способа игры Nim:

In this section we will start to write the procedures for playing a variation on the game of Nim. The first appearance of “official” rules for Nim is in a 1901 paper by Charles Bouton, in which he analyzed the game and presented a winning strategy. However, like many informal folk games, there are many different ways of playing Nim. All the variations start with objects of some sort arranged in some way. Two players alternate removing objects according to certain rules, and the player who takes the last object is the winner (or the loser, in some variations). We present three ways to play Nim:
