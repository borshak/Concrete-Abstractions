## Часть II
## Абстракция данных

В предыдущей части мы рассмотрели, как процедуры описывают вычислительные процессы. В этой части мы обратим наше внимание на данные, которыми манипулируют эти процессы и как они могут быть структурированы. Существует много качественно разных способов структурирования данных. Например, список остановок для автобусного маршрута имеет мало общего с чьим-то семейным деревом. В этой части мы сосредоточимся на нескольких характерных структурах данных и наборе операций, подходящих для каждого из них.

In the previous part, we looked at how procedures describe computational processes. In this part, we will turn our attention to the data that is manipulated by those processes and how it can be structured. There are many qualitatively dissimilar ways of structuring data. For example, the list of stops for a bus route bears little resemblance to someone’s family tree. In this part, we’ll focus on a few representative data structures and the collection of operations that is appropriate to each one.

В главе 6 мы рассмотрим основы использования и представления составных данных в относительно простом контексте типов данных с фиксированным числом компонентов. Мы сосредоточимся на наборе операций, которые образуют интерфейс между использованием типа данных и его представлением. В главе 7 мы покажем, как двухкомпонентные структуры данных могут фактически использоваться для представления списков любой длины, рассматривая каждый непустой список как имеющий первый элемент и список остальных элементов. Мы продолжим этот рекурсивный подход к структурированию данных для иерархических древовидных структур в главе 8. Далее мы рассмотрим, как разнообразная коллекция различных представлений данных может представлять единый, универсальный набор операций интерфейса. Наконец, мы рассмотрим программы как сами по себе иерархически скомпонованные данные (выражения, сделанные из подвыражений), и посмотрим, как обеспечить равномерную операцию «оценки» для разнообразия разных типов выражений. Поступая таким образом, мы покажем, что реализация языка программирования - это действительно конкретное приложение методов, представленных в этой части книги.

In Chapter 6, we’ll work through the fundamentals of using and representing compound data in the relatively simple context of data types with a fixed number of components. Our focus is on the collection of operations that forms the interface between the uses of the data type and its representation. In Chapter 7, we’ll show how two-component data structures can actually be used to represent lists of any length, by treating each nonempty list as having a first element and a list of the remaining elements. We’ll extend this recursive approach to structuring data to hierarchical, tree-like structures in Chapter 8. Next we’ll examine how a diverse collection of different data representations can present a single, uniform collection of interface operations. Finally, we’ll look at programs as themselves being hierarchically composed data (expressions made of subexpressions) and see how to provide a uniform “evaluate” operation across the diversity of different expression types. By doing so, we’ll show that implementing a programming language is really a specific application of the techniques introduced in this part of the book.

### Глава 6
### Составные данные и абстракция данных
#### 6.1 Введение

До сих пор каждое значение, переданное одной из наших процедур в качестве аргумента или возвращаемое в результате, было единственной вещью: числом, изображением, значением истины или процедурой. Если мы хотим передать процедуре два числа, нам нужны два отдельных аргумента, потому что каждое значение аргумента может быть только одной вещью. Такие данные называются атомарными данными. С другой стороны, вы можете легко представить себе программы, которые используют более сложные данные. Например, программа, которая играет в покер, использует руки карт. Там может быть процедура сравнения рук, которая принимает два аргумента, а именно две руки для сравнения, и отчеты, которые лучше. Каждый аргумент этой процедуры - это одна вещь, а именно рука. Тем не менее, мы также можем выбрать отдельную карту из руки. Таким образом, в то время как рука - это единая вещь, она также является коллекцией компонентных карт. Как насчет самих карт? Каждая карта - это однозначно одна вещь, но мы также можем рассматривать ее как комбинацию костюма и ранга. Такие данные, которые мы можем интерпретировать как единый объект, а также как набор частей, называются составными данными.

Up until now, each value passed to one of our procedures as an argument or returned as a result was a single thing: a number, an image, a truth value, or a procedure. If we wanted to pass a procedure two numbers, we needed two separate arguments, because each argument value could only be a single thing. This kind of data is called atomic data. On the other hand, you can easily think of programs that use more complex data. For example, a program that plays poker would use hands of cards. There might be a compare-hands procedure that takes two arguments, namely, the two hands to compare, and reports which is better. Each argument to this procedure is a single thing, namely, a hand. Yet we can also select an individual card from a hand. So, at the same time as the hand is a single thing, it is also a collection of component cards. How about the cards themselves? Each card is clearly a single thing, yet we can also treat it as a combination of a suit and a rank. Data such as this, which we can interpret as both a single entity and also as a collection of parts, is called compound data.

Чтобы увидеть, как мы можем заставить компьютер перемещаться по этим странным водам между сингулярным и множественным числом, рассмотрим следующий сценарий. Предположим, вы запустили компанию по заказу по почте и хотите начать продавать заказные «носки» для хвостов кошек - отлично для тех холодных ночей. (Полагаю, вы все поймете на рынке). Проблема заключается в том, что в вашем бланке заказа есть место только для одного номера модели, но заказчику нужно указать длину (до ближайшего сантиметра), а также независимо от того, Им нужна версия deluxe (мохер). Другими словами, они должны отправить вам комбинацию числа (длины) и истинного значения (независимо от того, будет или нет), но можете отправить только одну вещь - номер модели. Чем ты занимаешься? Вы нанимаете консалтинговую фирму.

In order to see how we can get a computer to navigate these strange waters between singular and plural, consider the following scenario. Suppose you run a mail-order company and want to start selling custom-knit “socks” for cats’ tails—great for those cold nights. (You figure you’ll have the market all to yourself.) The problem is, your order form only has space for a single model number, but the customer needs to specify both the length (to the nearest centimeter) and also whether or not they want the deluxe (mohair) version. In other words, they need to send you a combination of a number (the length) and a truth value (whether or not deluxe) but can only send in one thing—the model number. What do you do? You hire a consulting firm.

Консалтинговая фирма разрабатывает три калькулятора типа гизмо с клавиатурами и дисплеями. Один из них, конструктор, должен быть отправлен вашим клиентам вместе со своими каталогами. Он строит номер модели по длине и выбору deluxeness. Другие две вещицы, селектора, предназначены для использования в вашей компании. Селектор deluxeness отображает «да» или «нет» на своем дисплее при вводе номера модели. При вводе номера модели селектор длины показывает длину в сантиметрах.

The consulting firm designs three calculator-like gizmos with keypads and displays. One of them, the constructor, is to be mailed out to your customers along with their catalogs. It constructs the model number from the length and the deluxeness choice. The other two gizmos, the selectors, are for use at your company. The deluxeness selector displays “yes” or “no” on its display when you enter a model number. The length selector displays the length in centimeters when you enter a model number.

Вы и ваши клиенты можете использовать эти устройства без необходимости знать что-либо о том, как они работают. В частности, вам не нужно знать, как две части информации закодированы в номер модели. Напротив, консультанты, разработавшие гизмосы (и которые, вероятно, будут единственными, кто разбогатеет по всей этой необдуманной схеме), должны решить эту кодировку. Им нужно выбрать конкретное представление двух частей информации, и это же представление должно быть воплощено как в конструкторе, так и в селекторах.

You and your customers can use these devices without needing to know anything about how they work. In particular, you don’t need to know how the two pieces of information are encoded into the model number. In contrast, the consultants who designed the gizmos (and who are likely to be the only ones who get rich on this whole harebrained scheme) need to decide on this encoding. They need to choose a particular representation of the two pieces of information, and this same representation needs to be embodied in both the constructor and the selectors.

Эта идея, что представление данных может быть исключительно заботой конструктора и селекторов, а не конечных создателей и пользователей данных, называется абстракцией данных. В несколько более общих терминах абстракция данных относится к разделению способа использования нового типа данных по способу представления. Это означает, что когда мы добавляем новый тип данных, мы сначала решаем, какие операции (процедуры) необходимы для создания и манипулирования значениями данных. Затем мы выясним хороший способ представления значений данных с использованием типов, которые уже являются частью нашей системы Scheme. Наконец, мы находим алгоритмы, необходимые для реализации основных операций. Всякий раз, когда мы используем новый тип данных в другой программе, мы создаем и манипулируем значениями данных только с помощью основных операций, а не посредством доступа к базовому представлению данных.

This idea, that the representation of data can be exclusively the concern of a constructor and selectors, rather than of the ultimate creators and users of the data, is known as data abstraction. In slightly more general terms, data abstraction refers to separating the way a new type of data is used from the way it is represented. This means that when we add a new data type, we first decide what operations (procedures) are necessary to create and manipulate the data values. Then we figure out a good way of representing the data values using the types that are already part of our Scheme system. Finally, we find algorithms necessary for implementing the essential operations. Whenever we use the new data type in another program, we create and manipulate the data values only by using the essential operations, and not by accessing the underlying representation of the data.

Самодисциплина абстракции данных приносит три награды. Прежде всего, указав основные операции, которые манипулируют новым типом данных, программисту не нужно беспокоиться о том, как фактически отображаются значения данных. Это означает, что она может работать с абстрактной моделью данных, которые она имеет в своей голове, вместо того, чтобы постоянно переключаться с модели на базовое представление и обратно. (Говорят, что программист, работающий в этом независимом от представления виде, использует абстрактный тип данных или ADT.) Во-вторых, если мы отделим способ использования данных от того, как они реализованы, реализация может быть разработана независимо от программ Используя данные. Из-за этого мы часто можем разбить большой проект программирования на части, которые одновременно могут работать разные команды программистов. Наконец, поскольку прикладные программы обращаются к данным только через основные операции, мы можем легко изменить способ представления данных, просто изменив эти процедуры. В частности, если мы хотим переместить крупную программу (например, систему Scheme) с одного типа компьютера на другой (этот процесс называется портированием), большая часть работы ограничена модификацией реализаций ADT.

The self-discipline of data abstraction brings three rewards. First of all, by specifying the basic operations that manipulate the new data type, the programmer needn’t worry about how the data values are actually represented. This means that she can work with the abstract model of the data that she has in her head rather than constantly switching from the model to the underlying representation and back. (A programmer working in this representation-independent way is said to be using an abstract data type, or ADT .) Secondly, if we separate the way the data is used from how it is implemented, the implementation can be developed independently from the programs using the data. Because of this, we can often break down a large programming project into pieces that different teams of programmers can work on simultaneously. Finally, because the application programs access the data only through the basic operations, we can easily change the way the data is represented by simply changing these procedures. In particular, if we want to move a large software program (such as the Scheme system) from one type of computer to another (this process is called porting), a lot of the work is restricted to modifying the ADT implementations.

В оставшейся части этой главы мы проиллюстрируем технику абстракции данных, написав программу, которая играет в игру Nim. Это наш первый пример интерактивной программы, тем самым вводя читателя в некоторые простые процедуры ввода и вывода в Scheme. В большей части этой главы наши составные данные будут содержать только два компонента; Однако мы покажем, как создавать типы данных с тремя компонентами в разделе 6.4. Этот метод может быть распространен на любое (фиксированное) количество компонентов. В разделе нашего приложения рассматривается использование более высокого порядка программирования вместе с абстракцией данных для добавления стратегий в игру Nim.

In the remainder of this chapter, we illustrate the technique of data abstraction by writing a program that plays the game of Nim. This is our first example of an interactive program, thereby introducing the reader to some simple input and output procedures in Scheme. For most of this chapter, our compound data will have only two components; however, we show how to create data types with three components in Section 6.4. This technique can be extended to any (fixed) number of components. Our application section considers how to use higher-order programming together with data abstraction to add strategies to the game of Nim.

В последующих главах мы рассматриваем более сложные структуры данных, такие как списки и иерархически структурированные данные, которые не ограничивают количество компонентов в данных. Мы также рассматриваем сложные «общие» операторы, которые могут использоваться для нескольких типов данных. Наконец, мы применяем эти идеи к особому виду сложных данных, программам и особенно интересной операции - запуску этих программ.

In later chapters, we consider more complex data structures, such as lists and hierarchically structured data, that do not restrict the number of components in the data. We also consider complex “generic” operators that can be used on multiple data types. Finally, we apply these ideas to one very special kind of compound data, programs, and a particularly interesting operation, the running of those programs.

### 6.1 Игра Nim

В этом разделе мы начнем писать процедуры для воспроизведения вариаций в игре Nim. Первое появление «официальных» правил для Нима содержится в статье Чарльза Бутона в 1901 году, в которой он проанализировал игру и представил выигрышную стратегию. Однако, как и во многих неофициальных народных играх, существует множество различных способов игры с Нимом. Все варианты начинаются с объектов, которые каким-то образом устроены. Два игрока поочередно удаляют объекты по определенным правилам, а игрок, который берет последний объект, является победителем (или проигравшим, в некоторых вариантах). Мы представляем три способа игры Nim:

In this section we will start to write the procedures for playing a variation on the game of Nim. The first appearance of “official” rules for Nim is in a 1901 paper by Charles Bouton, in which he analyzed the game and presented a winning strategy. However, like many informal folk games, there are many different ways of playing Nim. All the variations start with objects of some sort arranged in some way. Two players alternate removing objects according to certain rules, and the player who takes the last object is the winner (or the loser, in some variations). We present three ways to play Nim:

1. Версия, которую мы назовем трехмерной стопкой Nim, представлена в статье Бутона. Играется с тремя кучами предметов, например, с монетами. Когда игра начинается, три кучки имеют разное количество монет. Два игрока по очереди снимают монеты. Каждый игрок должен взять хотя бы одну монету за ход и может занять больше времени, чем все они из одной и той же кучи. Победителем является игрок, который берет последнюю монету (или монеты). Поскольку найти выигрышную стратегию для этой версии относительно легко, Бутон предложил вариант, в котором игрок, который берет последнюю монету, теряет игру.

1. The version we’ll call three-pile Nim is presented in Bouton’s paper. It is played using three piles of objects, say coins. When the game starts, the three piles have different numbers of coins. Two players take turns removing coins. Each player must take at least one coin each turn and may take more as long as they are all from the same pile. The winner is the player who takes the last coin (or coins). Because finding a winning strategy for this version is relatively easy, Bouton suggested the variation in which the player who takes the last coin loses the game.

--

2. Вместо трех свай можно использовать некоторое количество свай, каждое из которых начинается с некоторого количества монет. Игра продолжается точно так же, как и выше, при этом победитель (или проигравший) является последним, кто удалит одну или несколько монет. В частности, в этой главе мы будем работать с двухсоставной версией.

2. Instead of three piles, some other number of piles can be used, each starting with some arbitrary number of coins in it. The game proceeds exactly as above, with the winner (or loser) being the last person to remove one or more coins. In particular, we’ll work with the two-pile version in most of this chapter.

--

3. Окончательная версия - самая вкусная. Игра не будет концептуально различной, если что-то еще будет постепенно уменьшено, кроме количества монет в кучах. Как насчет количества строк и количества столбцов на панели шоколада? Вы начинаете с того типа шоколадных батончиков, который забивается в строки и столбцы, чтобы вы могли разбить его на маленькие квадратики. Представьте, что квадрат в нижнем левом углу отравлен. Игроки по очереди разбивают планку на две части, разбивая одну из горизонтальных канавок или одну из вертикальных канавок в баре, а затем съедая участок, не содержащий отравленного квадрата. В конце концов, один игрок останется с одним квадратом, который отравлен. Этот игрок проигрывает.

3. The final version is the tastiest one. The game wouldn’t be conceptually any different if something else were progressively reduced other than the number of coins in piles. How about the number of rows and the number of columns in a chocolate bar? You start with the kind of chocolate candy bar that is scored into rows and columns so that you could break it into small squares. Pretend that the square in the bottom left-hand corner is poisoned. The players take turns breaking the bar into two pieces by breaking along one of the horizontal grooves or one of the vertical grooves in the bar and then eating the section not containing the poisoned square. Eventually, one player will be left with just one square, which is poisoned. That player loses.

Как последняя версия связана с предыдущими двумя? На самом деле это эквивалентно двухпунктовому Nim. Чтобы убедиться в этом, вам нужно понять, что панель моноблока полностью определяется количеством горизонтальных и вертикальных канавок (или десятков). Если мы представляем планку двумя кучами, один с монетой для каждого горизонтального счета, а другой с монетой для каждого вертикального счета, разбивая леденец по вертикальной или горизонтальной шкале, соответствует удалению монет из одной из свай и окончанию С отравленным квадратом соответствует тому, что оба кучи пусты (потому что, когда столбик опускается до одного квадрата, баллов не осталось). Ломать шоколад на последнем месте, его можно сломать, это взять последнюю монету.

How is the last version related to the previous two? In fact it is equivalent to twopile Nim. To see this, you need to realize that the candy bar is completely specified by the number of horizontal and vertical grooves (or scores). If we represent the bar by two piles, one with a coin for each horizontal score and the other with a coin for each vertical score, breaking the candy bar along a vertical or horizontal score corresponds to removing coins from one of the piles, and ending with the poisoned square corresponds to both piles being empty (because when the bar is down to a single square, there are no scores left). Breaking the chocolate at the last place it can be broken is like taking the last coin.

Прежде чем мы напишем программу для компьютера, чтобы играть в Nim с человеком-пользователем, мы должны сначала решить, какую версию мы хотим играть. Мы решили сконцентрироваться на двухвалютной версии, причем победителем будет игрок, который берет последнюю монету. Как видно из вышеприведенного обсуждения, не имеет значения, играем ли мы на самом деле с двумя стопками монет или вместо этого используем шоколадку. Когда мы играем с компьютером, мы, по-видимому, не будем использовать ни физические штабеля, ни шоколадную плиту, а скорее третий вариант, более подходящий для возможностей компьютера. Чтобы узнать, как играть в Nim, найдите себе партнера и сыграйте в несколько игр. (Мы отказываемся от любой ответственности, если вы выбираете версию шоколадного батончика.) Когда вы играете, подумайте о том, как вы могли бы написать программу, которая могла бы сыграть с вами Ним.

Before we write a program for the computer to play Nim with a human user, we must first decide which version we want to play. We’ve chosen to concentrate on the two-pile version, with the winner being the player who takes the last coin. As the above discussion suggests, it doesn’t matter whether we actually play with two piles of coins or, instead, use a chocolate bar. When we play with the computer, we presumably won’t use either physical piles or a chocolate bar, but rather some third option better suited to the computer’s capabilities. To get a feel for how to play Nim, find a partner and play a few games. (We disclaim all responsibility if you choose the chocolate bar version.) As you play, think about how you might write a program that could play Nim with you.

What type of data will such a program need? If you think about how you played, you will see that you and your partner started with a particular configuration of coins and took turns transforming the current configuration into a new configuration by making legal moves. The configuration of the coins in the two piles described the state (or condition) of the game at a given time. For this reason, we will call the configurations game states; they are our new data type. That is, we will arrange things so that we can pass a game state into a procedure as an argument or return a game state as the result of a procedure, just as we can with any other type of value. That way, the transformation you do in making a move can be a procedure. Game states can be physically represented by two piles of coins, which we call the first pile and the second pile.

Next, find a third person to be a gamekeeper and play another game with your partner. This time, instead of physically removing coins from piles, have the gamekeeper do all the work. The gamekeeper should keep track of the individual game states; you and your partner will give him directions and ask him questions. As you play, concentrate on what directions you give the gamekeeper and what questions you ask. You should discover that you repeatedly ask how many coins there are in a particular pile of the current game state and that you tell the gamekeeper to change to a new game state by removing some number of coins from a particular pile. This tells us that there are at least two operations we need for our data structure. One tells us how many coins are in either one of the piles and the other allows us to “remove” a specified number of coins from a pile, by making a new state with fewer coins in that pile. In Scheme, we could specify these operations as follows:

```scheme
(size-of-pile game-state p)
;returns an integer equal to the number of coins in the p-th
;pile of the game-state
(remove-coins-from-pile game-state n p)
;given a Nim game-state, returns a new game state with n
;fewer coins in pile p
```
We will also need an operation that creates a new game state with a specified number of coins in each pile. This operation is what is used to set up an initial game state:

```scheme
(make-game-state n m)
;returns a game state with n coins in the first pile
;and m coins in the second pile
```



